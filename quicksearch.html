<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_repository.js.html":{"id":"lib_repository.js.html","title":"Source: lib/repository.js","body":" Gitty Modules gittygitty/parser Classes CommandRepository Source: lib/repository.js 'use strict'; var fs = require('fs'); var path = require('path'); var util = require('util'); var Command = require('./command'); var parse = require('./parser'); var events = require('events'); var logFmt = '--pretty=format:\\'{&quot;commit&quot;:&quot;%H&quot;,&quot;author&quot;:&quot;%an &lt;%ae&gt;&quot;,' + '&quot;date&quot;:&quot;%ad&quot;,&quot;message&quot;:&quot;%s&quot;}\\','; if (require('os').platform() === 'win32') { logFmt = '--pretty=format:{\\\\&quot;commit\\\\&quot;:\\\\&quot;&quot;%H&quot;\\\\&quot;,\\\\&quot;author\\\\&quot;:\\\\&quot;&quot;%an ^&lt;%ae^&gt;&quot;\\\\&quot;,' + '\\\\&quot;date\\\\&quot;:\\\\&quot;%ad\\\\&quot;,\\\\&quot;message\\\\&quot;:\\\\&quot;%s\\\\&quot;},'; } /** * Represents a Git repository * @constructor * @param {string} repo * @param {string} gitpath */ var Repository = function(repo, gitpath) { if (!(this instanceof Repository)) { return new Repository(repo, gitpath); } var self = this; events.EventEmitter.call(this); self.gitpath = gitpath ? path.normalize(gitpath) : ''; self.path = path.normalize(repo); self._ready = false; self.name = path.basename(self.path); fs.exists(self.path + '/.git', function(exists) { self.initialized = exists; self._ready = true; self.emit('ready'); }); }; util.inherits(Repository, events.EventEmitter); /** * Initializes the given directory as a git repository * @param {array} flags * @param {function} callback */ Repository.prototype.init = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var flags = Array.isArray(args[0]) ? args[0] : []; var done = args.slice(-1).pop() || function() { }; var cmd = new Command(self, 'init', flags, ''); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err || new Error(stderr)); } self.initialized = true; done(); }); }; /** * Initializes the given directory as a git repository * @param {array} flags * @param {function} callback */ Repository.prototype.initSync = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var flags = Array.isArray(args[0]) ? args[0] : []; var cmd = new Command(self, 'init', flags, ''); cmd.execSync(); self.initialized = true; return self.initialized; }; /** * Forwards the commit history to the callback function * @param {string} path - optional branch or path * @param {function} callback */ Repository.prototype.log = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var path = typeof args[0] === 'string' ? args[0] : ''; var done = args.slice(-1).pop() || function() { }; var cmd = new Command(self, 'log', [logFmt, path]); cmd.exec(function(err, stdout, stderr) { if (err || stderr) { return done(err || new Error(stderr)); } done(null, parse.log(stdout)); }); }; /** * Returns the commit history * @param {string} branch */ Repository.prototype.logSync = function(branch) { var self = this; var cmd = new Command(self, 'log', [logFmt, branch || '']); return parse.log(cmd.execSync()); }; /** * Forwards the git status object to the callback function * @param {array} flags * @param {function} callback */ Repository.prototype.status = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[0]) ? args[0] : []; var status = new Command(self, 'status', flags); var lsFiles = new Command(self, 'ls-files', ['-o','--exclude-standard']); status.exec(function(err, status, stderr) { if (err) { return done(err); } lsFiles.exec(function(err, untracked, stderr) { if (err) { return done(err); } done(null, parse.status(status, untracked)); }); }); }; /** * Returns the git status object * @param {array} flags */ Repository.prototype.statusSync = function(flags) { var self = this; var status = new Command(self, 'status', flags); var lsFiles = new Command(self, 'ls-files', ['-o','--exclude-standard']); return parse.status(status.execSync(), lsFiles.execSync()); }; /** * Stages the passed array of files for commiting * @param {array} files * @param {array} flags * @param {function} callback */ Repository.prototype.add = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var files = args[0]; var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[1]) ? args[1] : []; var cmd = new Command(self, 'add', flags, files.join(' ')); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null); }); }; /** * Stages the passed array of files for commiting * @param {array} files * @param {array} flags */ Repository.prototype.addSync = function(files, flags) { var self = this; var cmd = new Command(self, 'add', flags || [], files.join(' ')); return cmd.execSync(); }; /** * Removes the passed array of files from the repo for commiting * @param {array} files * @param {function} callback */ Repository.prototype.remove = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var files = args[0]; var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[1]) ? args[1] : ['--cached']; var cmd = new Command(self, 'rm', flags, files.join(' ')); cmd.exec(function(err, stdout, stderr) { if (err) { done(err); } done(null); }); }; /** * Removes the passed array of files from the repo for commiting * @param {array} files * @param {array} flags */ Repository.prototype.removeSync = function(files, flags) { var self = this; var cmd = new Command(self, 'rm', flags || ['--cached'], files.join(' ')); return cmd.execSync(); }; /** * Unstages the passed array of files from the staging area * @param {array} files * @param {array} flags * @param {function} callback */ Repository.prototype.unstage = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var files = args[0]; var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[1]) ? args[1] : []; var cmd = new Command(self, 'reset HEAD', flags, files.join(' ')); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null); }); }; /** * Unstages the passed array of files from the staging area * @param {array} files * @param {array} flags */ Repository.prototype.unstageSync = function(files, flags) { var self = this; var cmd = new Command(self, 'reset HEAD', flags || [], files.join(' ')); return cmd.execSync(); }; /** * Commits the staged area with the given message * @param {string} message * @param {array} flags * @param {function} callback */ Repository.prototype.commit = function() { var args = Array.prototype.slice.apply(arguments); var message = args[0]; var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[1]) ? args[1].concat('-m') : ['-m']; var cmd = new Command(this, 'commit', flags, '&quot;' + message + '&quot;'); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } var result = stdout ? parse.commit(stdout) : {}; if (result.error) { return done(result.error); } done(null, result); }); }; /** * Commits the staged area with the given message * @param {string} message * @param {array} flags */ Repository.prototype.commitSync = function(message, flags) { var self = this; flags = Array.isArray(flags) ? flags.push('-m') : ['-m']; var cmd = new Command(this, 'commit', flags, '&quot;' + message + '&quot;'); var output = cmd.execSync(); var result = output ? parse.commit(output) : {}; if (result.error) { throw new Error(result.error); } return result; }; /** * Forwards object with the current branch and all others to the callback * @param {function} callback */ Repository.prototype.getBranches = function(callback) { var self = this; var done = callback || function() { }; var cmd = new Command(self, 'branch'); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null, parse.branch(stdout)); }); }; /** * Returns a denoted object with the current branch and all other branches * @param {function} callback */ Repository.prototype.getBranchesSync = function() { var self = this; var cmd = new Command(self, 'branch'); return parse.branch(cmd.execSync()); }; /** * Creates a new branch with the given branch name * @param {string} name * @param {array} flags * @param {function} callback */ Repository.prototype.createBranch = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var name = args[0]; var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[1]) ? args[1] : []; var cmd = new Command(self, 'branch', flags, name); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null); }); }; /** * Creates a new branch with the given branch name * @param {string} name * @param {array} flags */ Repository.prototype.createBranchSync = function(name, flags) { var self = this; var cmd = new Command(self, 'branch', flags || [], name); return cmd.execSync(); }; /** * Performs a git checkout on the given branch * @param {string} branch * @param {array} flags * @param {function} callback */ Repository.prototype.checkout = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var branch = args[0]; var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[1]) ? args[1] : []; var cmd = new Command(self, 'checkout', flags, branch); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } self.getBranches(done); }); }; /** * Performs a git checkout on the given branch * @param {string} branch * @param {array} flags */ Repository.prototype.checkoutSync = function(branch, flags) { var self = this; var cmd = new Command(self, 'checkout', flags || [], branch); cmd.execSync(); return self.getBranchesSync(); }; /** * Performs a git merge in the current branch against the specified one * @param {string} branch * @param {array} flags * @param {function} callback */ Repository.prototype.merge = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var branch = args[0]; var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[1]) ? args[1] : []; var cmd = new Command(self, 'merge', flags, branch); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null); }); }; /** * Performs a git merge in the current branch against the specified one * @param {string} branch */ Repository.prototype.mergeSync = function(branch, flags) { var self = this; var cmd = new Command(self, 'merge', flags || [], branch); return cmd.execSync(); }; /** * Forwards a array of repositorys'tags to the callback function * @param {function} callback */ Repository.prototype.getTags = function(callback) { var self = this; var done = callback || function() { }; var cmd = new Command(self, 'tag'); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null, parse.tag(stdout)); }); }; /** * Forwards a array of repositorys'tags to the callback function */ Repository.prototype.getTagsSync = function() { var self = this; var cmd = new Command(self, 'tag'); return parse.tag(cmd.execSync()); }; /** * Creates a new tag from the given tag name * @param {string} name * @param {array} flags * @param {function} callback */ Repository.prototype.createTag = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var name = args[0]; var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[1]) ? args[1] : []; var cmd = new Command(self, 'tag', flags, name); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null); }); }; /** * Creates a new tag from the given tag name * @param {string} name * @param {array} flags */ Repository.prototype.createTagSync = function(name, flags) { var self = this; var cmd = new Command(self, 'tag', flags || [], name); return cmd.execSync(); }; /** * Adds a new remote * @param {string} remote * @param {string} url * @param {array} flags * @param {function} callback */ Repository.prototype.addRemote = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var remote = args[0]; var url = args[1]; var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[2]) ? args[2] : []; var cmd = new Command(self, 'remote add', flags, remote + ' ' + url); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null); }); }; /** * Adds a new remote * @param {string} remote * @param {string} url * @param {array} flags */ Repository.prototype.addRemoteSync = function(remote, url, flags) { var self = this; var cmd = new Command(self, 'remote add', flags || [], remote + ' ' + url); return cmd.execSync(); }; /** * Changes the URL of a existing remote * @param {string} remote * @param {string} url * @param {array} flags * @param {function} callback */ Repository.prototype.setRemoteUrl = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var remote = args[0]; var url = args[1]; var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[2]) ? args[2] : []; var cmd = new Command(self, 'remote set-url', flags, remote + ' ' + url); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null); }); }; /** * Changes the URL of a existing remote * @param {string} remote * @param {string} url * @param {array} flags * @param {function} callback */ Repository.prototype.setRemoteUrlSync = function(remote, url, flags) { var self = this; var cmd = new Command(self, 'remote set-url', flags || [], remote + ' ' + url); return cmd.execSync(); }; /** * Removes the given remote * @param {string} remote * @param {array} flags * @param {function} callback */ Repository.prototype.removeRemote = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var remote = args[0]; var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[1]) ? args[1] : []; var cmd = new Command(self, 'remote rm', flags, remote); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null); }); }; /** * Removes the given remote * @param {string} remote * @param {array} flags */ Repository.prototype.removeRemoteSync = function(remote, flags) { var self = this; var cmd = new Command(self, 'remote rm', flags || [], remote); return cmd.execSync(); }; /** * Forwards a key-value list (remote : url) to the callback function * @param {Function} callback */ Repository.prototype.getRemotes = function(callback) { var self = this; var done = callback || function() { }; var cmd = new Command(self, 'remote', ['-v']); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null, parse.remotes(stdout)); }); }; /** * Returns a key-value list (remote : url) * @param {function} callback */ Repository.prototype.getRemotesSync = function() { var self = this; var cmd = new Command(self, 'remote', ['-v']); return parse.remotes(cmd.execSync()); }; /** * Performs a GIT push to the given remote for the given branch name * @param {string} remote * @param {string} branch * @param {array} flags * @param {object} creds * @param {function} callback */ Repository.prototype.push = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var remote = args[0]; var branch = args[1]; var done = args.slice(-1).pop(); var flags = Array.isArray(args[2]) ? args[2] : null; var creds = null; if (flags &amp;&amp; args[3].username) { creds = args[3]; } else if (args[2] &amp;&amp; args[2].username) { creds = args[2]; } return sync(self, { operation: 'push', remote: remote, branch: branch, flags: flags, credentials: creds || { username: null, password: null } }, done); }; /** * Performs a GIT pull from the given remote with the given branch name * @param {string} remote * @param {string} branch * @param {array} flags * @param {object} creds * @param {function} callback */ Repository.prototype.pull = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var remote = args[0]; var branch = args[1]; var done = args.slice(-1).pop(); var flags = Array.isArray(args[2]) ? args[2] : null; var creds = null; if (flags &amp;&amp; args[3].username) { creds = args[3]; } else if (args[2].username) { creds = args[2]; } return sync(this, { operation: 'pull', remote: remote, branch: branch, flags: flags, credentials: creds || { username: null, password: null } }, done); }; /** * Performs a git fetch from the given remote * @param {string} remote * @param {array} flags * @param {function} callback */ Repository.prototype.fetch = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var remote = args[0]; var flags = Array.isArray(args[1]) ? args[1] : []; var done = args.slice(-1).pop(); var cmd = new Command(self, 'fetch', [flags].concat(remote)); cmd.exec(done); }; function sync(repo, opts, callback) { var done = callback || function() { }; var flags = opts.flags || []; var creds = opts.credentials; var options = [opts.remote, opts.branch].concat(flags); var cmd = new Command(repo, opts.operation, options); cmd.exec(function(err, stdout, stderr) { done(err); }); } /** * Resets the repository's HEAD to the specified commit * @param {string} hash * @param {function} callback */ Repository.prototype.reset = function(hash, callback) { var self = this; var done = callback || function() { }; var cmd = new Command(self, 'reset', ['--hard'], hash); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } self.log(function(err, log) { if (err) { return done(err); } done(null, log); }); }); }; /** * Resets the repository's HEAD to the specified commit * @param {string} hash */ Repository.prototype.resetSync = function(hash) { var self = this; var cmd = new Command(self, 'reset', ['--hard'], hash); cmd.execSync(); return self.logSync(); }; /** * Forwards the current commit hash to the callback function * @param {function} callback */ Repository.prototype.describe = function(callback) { var self = this; var done = callback || function() { }; var cmd = new Command(self, 'describe', ['--always']); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null, stdout); }); }; /** * Returns the current commit hash */ Repository.prototype.describeSync = function() { var self = this; var cmd = new Command(self, 'describe', ['--always']); return cmd.execSync(); }; /** * Allows cherry-picking * @param {string} commit - commit hash * @param {function} callback * @param {array} flags */ Repository.prototype.cherryPick = function() { var self = this; var args = Array.prototype.slice.apply(arguments); var commit = args[0]; var done = args.slice(-1).pop() || function() { }; var flags = Array.isArray(args[1]) ? args[1] : []; var cmd = new Command(self, 'cherry-pick', flags, commit); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null); }); }; /** * Allows cherry-picking * @param {string} commit - commit hash * @param {function} callback * @param {array} flags */ Repository.prototype.cherryPickSync = function(commit, flags) { var self = this; var cmd = new Command(self, 'cherry-pick', flags || [], commit); return cmd.execSync(); }; /** * Allows show * @param {string} commit * @param {string} filePath - full path of the file relative to the repo * @param {function} callback */ Repository.prototype.show = function(commit, filePath, callback) { var self = this; var done = callback || function() { }; var revision = commit + ':' + filePath; var cmd = new Command(self, 'show', [], revision); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null, stdout); }); }; /** * Allows show * @param {string} commit - commit hash * @param {string} filePath - full path of the file relative to the repo */ Repository.prototype.showSync = function(commit, filePath) { var self = this; var revision = commit + ':' + filePath; var cmd = new Command(self, 'show', [], revision); return cmd.execSync(); }; /** * Allows stashing uncommited files * @param {array} options * @param {Function} callback */ Repository.prototype.stash = function(opt, callback){ var self = this; var options = opt &amp;&amp; opt.join(' '); var done = callback || function() { }; var cmd = new Command(self, 'stash', [], options || ''); cmd.exec(function(err, stdout, stderr) { if (err) { return done(err); } done(null, stdout); }); }; /** * Allows stashing uncommited files * @param {array} options */ Repository.prototype.stashSync = function(opt){ var self = this; var options = opt &amp;&amp; opt.join(' '); var cmd = new Command(self, 'stash', [], options || ''); return cmd.execSync(); }; /** * Handles the global git configuration * @function * @param {string} key * @param {string} val * @param {function} callback */ Repository.setConfig = function(key, val, callback) { var cmd = new Command(null, 'config', ['--global', key], '&quot;' + val + '&quot;'); var done = callback || function() {}; cmd.exec(function(err, stdout, stderr) { done(err || null); }); }; /** * Handles the global git configuration * @function * @param {string} key * @param {string} val * @param {function} callback */ Repository.setConfigSync = function(key, val) { var cmd = new Command(null, 'config', ['--global', key], '&quot;' + val + '&quot;'); return cmd.execSync(); }; /** * Handles the global git configuration * @function * @param {string} key * @param {function} callback */ Repository.getConfig = function(key, callback) { var cmd = new Command(null, 'config', ['--global', key]); var done = callback || function() {}; cmd.exec(function(err, stdout, stderr) { done(err || null, stdout); }); }; /** * Handles the global git configuration * @function * @param {string} key * @param {function} callback */ Repository.getConfigSync = function(key) { var cmd = new Command(null, 'config', ['--global', key]); return cmd.execSync(); }; /** * Wrapper for the git clone function * @function * @param {string} path * @param {string} url * @param {object} creds * @param {function} callback */ Repository.clone = function(path, url) { var self = this; var args = Array.prototype.slice.apply(arguments); var creds = args[2].username ? args[2] : {}; var done = args.slice(-1).pop() || function() {}; var clone = new Command(null, 'clone', [url, path]); var error = null; clone.exec(function(err, stdout, stderr) { done(err); }); }; module.exports = Repository; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Gitty Modules gittygitty/parser Classes CommandRepository Source: index.js /** * @module gitty */ 'use strict'; var Repository = require('./lib/repository'); module.exports = Repository /** {@link Repository} */ module.exports.Repository = Repository; /** {@link Command} */ module.exports.Command = require('./lib/command'); × Search results Close "},"lib_command.js.html":{"id":"lib_command.js.html","title":"Source: lib/command.js","body":" Gitty Modules gittygitty/parser Classes CommandRepository Source: lib/command.js 'use strict'; var childproc = require('child_process'); var exec = childproc.exec; var execSync = childproc.execSync; /** * Setup function for running git commands on the command line * @constructor * @param {Repository} repo * @param {string} operation * @param {array} flags * @param {string} options */ var Command = function(repo, operation, flags, options) { flags = flags || []; options = options || ''; var largeOperations = ['log', 'ls-files']; if (typeof repo === 'string') { this.repo = { path: repo, gitpath: '' }; } else { this.repo = repo || { path: '/', gitpath: '' }; } this.command = (this.repo.gitpath ? this.repo.gitpath + ' ' : 'git ') + operation + ' ' + flags.join(' ') + ' ' + options; // The log on long lived active repos will require more stdout buffer. // The default (200K) seems sufficient for all other operations. this.execBuffer = 1024 * 200; if (largeOperations.indexOf(operation) &gt; -1) { this.execBuffer = 1024 * 5000; } }; /** * Executes the stored operation in the given path * @param {function} callback */ Command.prototype.exec = function(callback) { return exec(this.command, this._getExecOptions(), callback); }; /** * Executes the stored operation in the given path syncronously */ Command.prototype.execSync = function() { process.chdir(this.repo.path); return execSync(this.command, this._getExecOptions()).toString(); }; /** * Return options to be passed to exec/execSync * @private */ Command.prototype._getExecOptions = function() { return { cwd: this.repo.path, maxBuffer: this.execBuffer }; }; module.exports = Command; × Search results Close "},"lib_parser.js.html":{"id":"lib_parser.js.html","title":"Source: lib/parser.js","body":" Gitty Modules gittygitty/parser Classes CommandRepository Source: lib/parser.js /** * @module gitty/parser */ 'use strict'; /** * @function * @param {string} output * @return {string} */ module.exports.log = function(output) { var log = '[' + output.substring(0, output.length - 1) + ']'; // this function cleans the commit log from any double quotes breaking the // JSON string var jsonValueRegex = /&quot;.*?&quot;:&quot;(.*?)&quot;[,}]/g; var h = log.match(jsonValueRegex); if (h) { for (var i = h.length - 1; i &gt;= 0; i--) { var hh = h[i].replace(jsonValueRegex, '$1'); var hhh = hh.replace(/\\&quot;/g, '\\\\&quot;').replace(/\\'/g, ''); log = log.replace(hh, hhh); } } return JSON.parse(log); }; /** * Output Handler for GIT status * @function * @param {string} gitstatus * @param {string} untracked * @return {string} */ module.exports.status = function(gitstatus, untracked) { untracked = untracked.split('\\n'); var fileStatus = null; var output = gitstatus.split('\\n'); var status = { staged: [], unstaged: [], untracked: untracked.slice(0, untracked.length - 1), ahead: 0, behind: 0, diverged: false }; // iterate over lines output.forEach(function(line) { // switch to staged array if (line.match(/changes to be committed/i)) { fileStatus = 'staged'; } // or switch to not_staged array else if (line.match(/changes not staged for commit/i)) { fileStatus = 'unstaged'; } // or switch to untracked array else if (line.match(/untracked files/i)) { fileStatus = 'untracked'; } var isAhead = line.match(/is ahead.+by (\\d+)/i); var isBehind = line.match(/is behind.+by (\\d+)/i); var haveDiverged = line.match(/and have (\\d+) and (\\d+) different/i); var isModified = line.match(/modified/i); var isNewFile = line.match(/new file/i); var isDeleted = line.match(/deleted/i); if (isBehind) { status.behind = parseInt(isBehind[1]); } if (isAhead) { status.ahead = parseInt(isAhead[1]); } if (haveDiverged) { status.diverged = true status.ahead = parseInt(haveDiverged[1]) status.behind = parseInt(haveDiverged[2]) } // check if the line contains a keyword if (isModified || isNewFile || isDeleted) { // then remove # and all whitespace and split at the colon var fileinfo = line.substr(1).trim().split(':'); // push a new object into the current array status[fileStatus].push({ file: fileinfo[1].trim(), status: fileinfo[0] }); } }); return status; }; /** * Output handler for git commit * @function * @param {string} output * @return {string} */ module.exports.commit = function(output) { var commitFailed = (output.indexOf('nothing to commit') &gt; -1 || output.indexOf('no changes added to commit') &gt; -1); // if there is nothing to commit... if (commitFailed) { return { error: (function(output) { var lines = output.split('\\n'); for (var ln = 0; ln &lt; lines.length; ln++) { if (lines[ln].indexOf('#') === -1) { return lines[ln]; } } })(output) }; } var splitOutput = output.split('\\n'); var branchAndHash = splitOutput[0].match(/\\[([^\\]]+)]/g)[0]; var branch = branchAndHash.substring(1, branchAndHash.length - 1); var hash = branchAndHash.substring(1, branchAndHash.length - 1); var filesChanged = splitOutput[1].split(' ')[0]; var operations = splitOutput.splice(2); return { branch: branch.split(' ')[0], commit: hash.split(' ')[1], changed: filesChanged, operations: operations }; }; /** * Output handler for git branch command * @function * @param {string} output * @return {string} */ module.exports.branch = function(output) { var tree = { current: null, others: [] }; var branches = output.split('\\n'); branches.forEach(function(val, key) { if (val.indexOf('*') &gt; -1) { tree.current = val.replace('*', '').trim(); } else if (val) { tree.others.push(val.trim()); } }); return tree; }; /** * Output handler for git tag command * @function * @param {string} output * @return {string} */ module.exports.tag = function(output) { var tags = output.split(/\\r?\\n/); for (var i = 0; i &lt; tags.length; i++) { if (!tags[i].length) { tags.splice(i, 1); } } return tags; }; /** * Output handler for git remote -v command * @function * @param {string} output * @return {string} */ module.exports.remotes = function(output) { var list = {}; var parseme = output.split('\\n'); parseme.forEach(function(val, key) { if (val.split('\\t')[0]) { list[val.split('\\t')[0]] = val.split('\\t')[1].split(' ')[0]; } }); return list; }; /** * Output handler for git errors from git push and pull commands * @function * @param {string} output * @return {string} */ module.exports.syncErr = function(output) { var result = output.split('\\r\\n'); for (var i = 0; i &lt; result.length; i++) { if (!result[i].length) { result.splice(i, 1); } } return result; }; /** * Output handler for git success messages from git push and pull commands * @function * @param {string} output * @return {string} */ module.exports.syncSuccess = function(output) { return output; }; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Gitty Modules gittygitty/parser Classes CommandRepository Modules Classes Command Repository × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Gitty Modules gittygitty/parser Classes CommandRepository Classes Classes Command Repository × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Gitty Modules gittygitty/parser Classes CommandRepository Gitty Gitty is a Node.js wrapper for Git. It's syntax resembles the Git command line syntax, executes common commands, and parses the output into operable objects. Complete documentation is available here. InstallationPrerequisites Node.js 0.12.x (http://nodejs.org) Git 1.7.x.x (http://git-scm.com) $ npm install gittyTestingRun the the unit and integration tests with: $ npm testUsagevar git = require('gitty'); var myRepo = git('/path/to/repo');Now you can call this instance of Repository's methods. For example, to execute git log for myRepo, you would do: myRepo.log(function(err, log) { if (err) return console.log('Error:', err); // ... });Authenticated RepositoriesGitty no longer supports username/password authentication over SSH. You should be using SSH keys for that. myRepo.push('origin', 'master', function(err, succ) { if (err) return console.log(err); // ... });AuthorGitty was written by Gordon Hall (gordon@gordonwritescode.com)Licensed under LGPLv3 license × Search results Close "},"Repository.html":{"id":"Repository.html","title":"Class: Repository","body":" Gitty Modules gittygitty/parser Classes CommandRepository Class: Repository Repository new Repository(repo, gitpath) Represents a Git repository Parameters: Name Type Description repo string gitpath string Source: lib/repository.js, line 22 Methods checkout(branch, flags, callback) Performs a git checkout on the given branch Parameters: Name Type Description branch string flags array callback function Source: lib/repository.js, line 380 init(flags, callback) Initializes the given directory as a git repository Parameters: Name Type Description flags array callback function Source: lib/repository.js, line 51 initSync(flags, callback) Initializes the given directory as a git repository Parameters: Name Type Description flags array callback function Source: lib/repository.js, line 74 log(path, callback) Forwards the commit history to the callback function Parameters: Name Type Description path string optional branch or path callback function Source: lib/repository.js, line 92 logSync(branch) Returns the commit history Parameters: Name Type Description branch string Source: lib/repository.js, line 112 status(flags, callback) Forwards the git status object to the callback function Parameters: Name Type Description flags array callback function Source: lib/repository.js, line 124 statusSync(flags) Returns the git status object Parameters: Name Type Description flags array Source: lib/repository.js, line 151 add(files, flags, callback) Stages the passed array of files for commiting Parameters: Name Type Description files array flags array callback function Source: lib/repository.js, line 165 addSync(files, flags) Stages the passed array of files for commiting Parameters: Name Type Description files array flags array Source: lib/repository.js, line 187 remove(files, callback) Removes the passed array of files from the repo for commiting Parameters: Name Type Description files array callback function Source: lib/repository.js, line 199 removeSync(files, flags) Removes the passed array of files from the repo for commiting Parameters: Name Type Description files array flags array Source: lib/repository.js, line 221 unstage(files, flags, callback) Unstages the passed array of files from the staging area Parameters: Name Type Description files array flags array callback function Source: lib/repository.js, line 234 unstageSync(files, flags) Unstages the passed array of files from the staging area Parameters: Name Type Description files array flags array Source: lib/repository.js, line 256 commit(message, flags, callback) Commits the staged area with the given message Parameters: Name Type Description message string flags array callback function Source: lib/repository.js, line 269 commitSync(message, flags) Commits the staged area with the given message Parameters: Name Type Description message string flags array Source: lib/repository.js, line 296 getBranches(callback) Forwards object with the current branch and all others to the callback Parameters: Name Type Description callback function Source: lib/repository.js, line 314 getBranchesSync(callback) Returns a denoted object with the current branch and all other branches Parameters: Name Type Description callback function Source: lib/repository.js, line 332 createBranch(name, flags, callback) Creates a new branch with the given branch name Parameters: Name Type Description name string flags array callback function Source: lib/repository.js, line 345 createBranchSync(name, flags) Creates a new branch with the given branch name Parameters: Name Type Description name string flags array Source: lib/repository.js, line 367 checkoutSync(branch, flags) Performs a git checkout on the given branch Parameters: Name Type Description branch string flags array Source: lib/repository.js, line 402 merge(branch, flags, callback) Performs a git merge in the current branch against the specified one Parameters: Name Type Description branch string flags array callback function Source: lib/repository.js, line 417 mergeSync(branch) Performs a git merge in the current branch against the specified one Parameters: Name Type Description branch string Source: lib/repository.js, line 438 getTags(callback) Forwards a array of repositorys'tags to the callback function Parameters: Name Type Description callback function Source: lib/repository.js, line 449 getTagsSync() Forwards a array of repositorys'tags to the callback function Source: lib/repository.js, line 466 createTag(name, flags, callback) Creates a new tag from the given tag name Parameters: Name Type Description name string flags array callback function Source: lib/repository.js, line 479 createTagSync(name, flags) Creates a new tag from the given tag name Parameters: Name Type Description name string flags array Source: lib/repository.js, line 501 addRemote(remote, url, flags, callback) Adds a new remote Parameters: Name Type Description remote string url string flags array callback function Source: lib/repository.js, line 515 addRemoteSync(remote, url, flags) Adds a new remote Parameters: Name Type Description remote string url string flags array Source: lib/repository.js, line 539 setRemoteUrl(remote, url, flags, callback) Changes the URL of a existing remote Parameters: Name Type Description remote string url string flags array callback function Source: lib/repository.js, line 553 setRemoteUrlSync(remote, url, flags, callback) Changes the URL of a existing remote Parameters: Name Type Description remote string url string flags array callback function Source: lib/repository.js, line 578 removeRemote(remote, flags, callback) Removes the given remote Parameters: Name Type Description remote string flags array callback function Source: lib/repository.js, line 591 removeRemoteSync(remote, flags) Removes the given remote Parameters: Name Type Description remote string flags array Source: lib/repository.js, line 613 getRemotes(callback) Forwards a key-value list (remote : url) to the callback function Parameters: Name Type Description callback function Source: lib/repository.js, line 624 getRemotesSync(callback) Returns a key-value list (remote : url) Parameters: Name Type Description callback function Source: lib/repository.js, line 642 push(remote, branch, flags, creds, callback) Performs a GIT push to the given remote for the given branch name Parameters: Name Type Description remote string branch string flags array creds object callback function Source: lib/repository.js, line 657 pull(remote, branch, flags, creds, callback) Performs a GIT pull from the given remote with the given branch name Parameters: Name Type Description remote string branch string flags array creds object callback function Source: lib/repository.js, line 690 fetch(remote, flags, callback) Performs a git fetch from the given remote Parameters: Name Type Description remote string flags array callback function Source: lib/repository.js, line 721 reset(hash, callback) Resets the repository's HEAD to the specified commit Parameters: Name Type Description hash string callback function Source: lib/repository.js, line 749 resetSync(hash) Resets the repository's HEAD to the specified commit Parameters: Name Type Description hash string Source: lib/repository.js, line 773 describe(callback) Forwards the current commit hash to the callback function Parameters: Name Type Description callback function Source: lib/repository.js, line 786 describeSync() Returns the current commit hash Source: lib/repository.js, line 803 cherryPick(commit, callback, flags) Allows cherry-picking Parameters: Name Type Description commit string commit hash callback function flags array Source: lib/repository.js, line 816 cherryPickSync(commit, callback, flags) Allows cherry-picking Parameters: Name Type Description commit string commit hash callback function flags array Source: lib/repository.js, line 838 show(commit, filePath, callback) Allows show Parameters: Name Type Description commit string filePath string full path of the file relative to the repo callback function Source: lib/repository.js, line 851 showSync(commit, filePath) Allows show Parameters: Name Type Description commit string commit hash filePath string full path of the file relative to the repo Source: lib/repository.js, line 870 stash(options, callback) Allows stashing uncommited files Parameters: Name Type Description options array callback function Source: lib/repository.js, line 883 stashSync(options) Allows stashing uncommited files Parameters: Name Type Description options array Source: lib/repository.js, line 900 &lt;static&gt; setConfig(key, val, callback) Handles the global git configuration Parameters: Name Type Description key string val string callback function Source: lib/repository.js, line 914 &lt;static&gt; setConfigSync(key, val, callback) Handles the global git configuration Parameters: Name Type Description key string val string callback function Source: lib/repository.js, line 930 &lt;static&gt; getConfig(key, callback) Handles the global git configuration Parameters: Name Type Description key string callback function Source: lib/repository.js, line 942 &lt;static&gt; getConfigSync(key, callback) Handles the global git configuration Parameters: Name Type Description key string callback function Source: lib/repository.js, line 957 &lt;static&gt; clone(path, url, creds, callback) Wrapper for the git clone function Parameters: Name Type Description path string url string creds object callback function Source: lib/repository.js, line 971 × Search results Close "},"module-gitty.html":{"id":"module-gitty.html","title":"Module: gitty","body":" Gitty Modules gittygitty/parser Classes CommandRepository Module: gitty Source: index.js, line 1 Members &lt;static&gt; Command Command Source: index.js, line 13 &lt;static&gt; Repository Repository Source: index.js, line 11 × Search results Close "},"Command.html":{"id":"Command.html","title":"Class: Command","body":" Gitty Modules gittygitty/parser Classes CommandRepository Class: Command Command new Command(repo, operation, flags, options) Setup function for running git commands on the command line Parameters: Name Type Description repo Repository operation string flags array options string Source: lib/command.js, line 15 Methods exec(callback) Executes the stored operation in the given path Parameters: Name Type Description callback function Source: lib/command.js, line 40 execSync() Executes the stored operation in the given path syncronously Source: lib/command.js, line 47 × Search results Close "},"module-gitty_parser.html":{"id":"module-gitty_parser.html","title":"Module: gitty/parser","body":" Gitty Modules gittygitty/parser Classes CommandRepository Module: gitty/parser Source: lib/parser.js, line 1 Methods &lt;static&gt; log(output) Parameters: Name Type Description output string Source: lib/parser.js, line 12 Returns: Type string &lt;static&gt; status(gitstatus, untracked) Output Handler for GIT status Parameters: Name Type Description gitstatus string untracked string Source: lib/parser.js, line 41 Returns: Type string &lt;static&gt; commit(output) Output handler for git commit Parameters: Name Type Description output string Source: lib/parser.js, line 111 Returns: Type string &lt;static&gt; branch(output) Output handler for git branch command Parameters: Name Type Description output string Source: lib/parser.js, line 150 Returns: Type string &lt;static&gt; tag(output) Output handler for git tag command Parameters: Name Type Description output string Source: lib/parser.js, line 172 Returns: Type string &lt;static&gt; remotes(output) Output handler for git remote -v command Parameters: Name Type Description output string Source: lib/parser.js, line 190 Returns: Type string &lt;static&gt; syncErr(output) Output handler for git errors from git push and pull commands Parameters: Name Type Description output string Source: lib/parser.js, line 209 Returns: Type string &lt;static&gt; syncSuccess(output) Output handler for git success messages from git push and pull commands Parameters: Name Type Description output string Source: lib/parser.js, line 227 Returns: Type string × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
